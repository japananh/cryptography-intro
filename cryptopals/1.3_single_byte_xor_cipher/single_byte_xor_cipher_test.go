package singlebytexorcipher

import (
	"reflect"
	"testing"
)

func Test_Xor(t *testing.T) {
	type args struct {
		b1 []byte
		b2 []byte
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			name: "Test 1.2_xor run successfully",
			args: args{
				b1: []byte{1, 2, 3},
				b2: []byte{4, 5, 6},
			},
			want:    []byte{5, 7, 5},
			wantErr: false,
		},
		{
			name: "Should throw error on input not have the same length",
			args: args{
				b1: []byte{1, 2, 3},
				b2: []byte{4, 5},
			},
			want:    nil,
			wantErr: true,
		},
		{
			name: "Should throw error on input empty",
			args: args{
				b1: []byte{},
				b2: []byte{},
			},
			want:    []byte{},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Xor(tt.args.b1, tt.args.b2)
			if (err != nil) != tt.wantErr {
				t.Errorf("1.2_xor() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("1.2_xor() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_crackXorCipher(t *testing.T) {
	type args struct {
		cipherbytes []byte
		freqs       map[byte]float64
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			name: "Test crackXorCipher run successfully",
			args: args{
				cipherbytes: []byte{27, 55, 55, 51, 49, 54, 63, 120, 21, 27, 127, 43, 120, 52, 49, 51, 61, 120, 57, 120, 40, 55, 45, 54, 60, 120, 55, 62, 120, 58, 57, 59, 55, 54},
				freqs:       map[byte]float64{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0, 16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0, 32: 0.16516097752432846, 33: 0.0005517910120401261, 34: 5.079247809574382e-05, 35: 2.308749004351992e-06, 36: 4.617498008703984e-06, 37: 2.308749004351992e-06, 38: 0, 39: 1.6161243030463944e-05, 40: 7.618871714361573e-05, 41: 7.618871714361573e-05, 42: 3.693998406963187e-05, 43: 0, 44: 0.011786163667216918, 45: 0.0004525148048529904, 46: 0.007251780622669606, 47: 1.385249402611195e-05, 48: 4.848372909139183e-05, 49: 0.00024472739446131114, 50: 8.080621515231972e-05, 51: 5.3101227100095814e-05, 52: 3.924873307398386e-05, 53: 3.463123506527988e-05, 54: 2.77049880522239e-05, 55: 5.079247809574382e-05, 56: 3.924873307398386e-05, 57: 3.463123506527988e-05, 58: 0.0001408336892654715, 59: 0.002244104032230136, 60: 0, 61: 0, 62: 0, 63: 0.0005079247809574382, 64: 0, 65: 0.0009812183268495965, 66: 0.0005933484941184619, 67: 0.0004917635379269742, 68: 0.0003047548685744629, 69: 0.0007180209403534694, 70: 0.0004963810359356782, 71: 0.0004640585498747504, 72: 0.0007249471873665255, 73: 0.007351056829856742, 74: 0.00016392117930899143, 75: 7.157121913491175e-05, 76: 0.0003024461195701109, 77: 0.0007018596973230055, 78: 0.0003186073626005749, 79: 0.00038094358571807865, 80: 0.00041326607177900654, 81: 2.308749004351992e-06, 82: 0.0002516536414743671, 83: 0.0008080621515231971, 84: 0.0015029956018331467, 85: 0.00015699493229593545, 86: 0.00010158495619148764, 87: 0.0006649197132533736, 88: 4.617498008703984e-06, 89: 0.00037401733870502267, 90: 0, 91: 1.1543745021759959e-05, 92: 0, 93: 1.1543745021759959e-05, 94: 0, 95: 0.00019393491636556732, 96: 0, 97: 0.060766273794544426, 98: 0.011003497754741593, 99: 0.020924192226442102, 100: 0.038611518348782715, 101: 0.10568067692520808, 102: 0.019642836529026746, 103: 0.01334226049615016, 104: 0.04489131564062013, 105: 0.04938875870109781, 106: 0.0009950708208757086, 107: 0.003991827028524594, 108: 0.02907869370981334, 109: 0.02376395350179505, 110: 0.05591559213640089, 111: 0.05791035127616101, 112: 0.013743982822907407, 113: 0.0007457259284056934, 114: 0.04792962933034735, 115: 0.048070463019612826, 116: 0.06875454534960232, 117: 0.0238770822030083, 118: 0.00873861498147229, 119: 0.017006245166056772, 120: 0.0015584055779375946, 121: 0.01792743601879322, 122: 0.0004917635379269742, 123: 0, 124: 0, 125: 0, 126: 0, 127: 0},
			},
			want:    []byte{67, 111, 111, 107, 105, 110, 103, 32, 77, 67, 39, 115, 32, 108, 105, 107, 101, 32, 97, 32, 112, 111, 117, 110, 100, 32, 111, 102, 32, 98, 97, 99, 111, 110},
			wantErr: false,
		},
		{
			name: "Test crackXorCipher run successfully on input empty",
			args: args{
				cipherbytes: []byte{},
				freqs:       map[byte]float64{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0, 16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0, 32: 0.16516097752432846, 33: 0.0005517910120401261, 34: 5.079247809574382e-05, 35: 2.308749004351992e-06, 36: 4.617498008703984e-06, 37: 2.308749004351992e-06, 38: 0, 39: 1.6161243030463944e-05, 40: 7.618871714361573e-05, 41: 7.618871714361573e-05, 42: 3.693998406963187e-05, 43: 0, 44: 0.011786163667216918, 45: 0.0004525148048529904, 46: 0.007251780622669606, 47: 1.385249402611195e-05, 48: 4.848372909139183e-05, 49: 0.00024472739446131114, 50: 8.080621515231972e-05, 51: 5.3101227100095814e-05, 52: 3.924873307398386e-05, 53: 3.463123506527988e-05, 54: 2.77049880522239e-05, 55: 5.079247809574382e-05, 56: 3.924873307398386e-05, 57: 3.463123506527988e-05, 58: 0.0001408336892654715, 59: 0.002244104032230136, 60: 0, 61: 0, 62: 0, 63: 0.0005079247809574382, 64: 0, 65: 0.0009812183268495965, 66: 0.0005933484941184619, 67: 0.0004917635379269742, 68: 0.0003047548685744629, 69: 0.0007180209403534694, 70: 0.0004963810359356782, 71: 0.0004640585498747504, 72: 0.0007249471873665255, 73: 0.007351056829856742, 74: 0.00016392117930899143, 75: 7.157121913491175e-05, 76: 0.0003024461195701109, 77: 0.0007018596973230055, 78: 0.0003186073626005749, 79: 0.00038094358571807865, 80: 0.00041326607177900654, 81: 2.308749004351992e-06, 82: 0.0002516536414743671, 83: 0.0008080621515231971, 84: 0.0015029956018331467, 85: 0.00015699493229593545, 86: 0.00010158495619148764, 87: 0.0006649197132533736, 88: 4.617498008703984e-06, 89: 0.00037401733870502267, 90: 0, 91: 1.1543745021759959e-05, 92: 0, 93: 1.1543745021759959e-05, 94: 0, 95: 0.00019393491636556732, 96: 0, 97: 0.060766273794544426, 98: 0.011003497754741593, 99: 0.020924192226442102, 100: 0.038611518348782715, 101: 0.10568067692520808, 102: 0.019642836529026746, 103: 0.01334226049615016, 104: 0.04489131564062013, 105: 0.04938875870109781, 106: 0.0009950708208757086, 107: 0.003991827028524594, 108: 0.02907869370981334, 109: 0.02376395350179505, 110: 0.05591559213640089, 111: 0.05791035127616101, 112: 0.013743982822907407, 113: 0.0007457259284056934, 114: 0.04792962933034735, 115: 0.048070463019612826, 116: 0.06875454534960232, 117: 0.0238770822030083, 118: 0.00873861498147229, 119: 0.017006245166056772, 120: 0.0015584055779375946, 121: 0.01792743601879322, 122: 0.0004917635379269742, 123: 0, 124: 0, 125: 0, 126: 0, 127: 0},
			},
			want:    nil,
			wantErr: true,
		},
		{
			name: "Test crackXorCipher run successfully on input nil",
			args: args{
				cipherbytes: nil,
				freqs:       map[byte]float64{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0, 16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0, 32: 0.16516097752432846, 33: 0.0005517910120401261, 34: 5.079247809574382e-05, 35: 2.308749004351992e-06, 36: 4.617498008703984e-06, 37: 2.308749004351992e-06, 38: 0, 39: 1.6161243030463944e-05, 40: 7.618871714361573e-05, 41: 7.618871714361573e-05, 42: 3.693998406963187e-05, 43: 0, 44: 0.011786163667216918, 45: 0.0004525148048529904, 46: 0.007251780622669606, 47: 1.385249402611195e-05, 48: 4.848372909139183e-05, 49: 0.00024472739446131114, 50: 8.080621515231972e-05, 51: 5.3101227100095814e-05, 52: 3.924873307398386e-05, 53: 3.463123506527988e-05, 54: 2.77049880522239e-05, 55: 5.079247809574382e-05, 56: 3.924873307398386e-05, 57: 3.463123506527988e-05, 58: 0.0001408336892654715, 59: 0.002244104032230136, 60: 0, 61: 0, 62: 0, 63: 0.0005079247809574382, 64: 0, 65: 0.0009812183268495965, 66: 0.0005933484941184619, 67: 0.0004917635379269742, 68: 0.0003047548685744629, 69: 0.0007180209403534694, 70: 0.0004963810359356782, 71: 0.0004640585498747504, 72: 0.0007249471873665255, 73: 0.007351056829856742, 74: 0.00016392117930899143, 75: 7.157121913491175e-05, 76: 0.0003024461195701109, 77: 0.0007018596973230055, 78: 0.0003186073626005749, 79: 0.00038094358571807865, 80: 0.00041326607177900654, 81: 2.308749004351992e-06, 82: 0.0002516536414743671, 83: 0.0008080621515231971, 84: 0.0015029956018331467, 85: 0.00015699493229593545, 86: 0.00010158495619148764, 87: 0.0006649197132533736, 88: 4.617498008703984e-06, 89: 0.00037401733870502267, 90: 0, 91: 1.1543745021759959e-05, 92: 0, 93: 1.1543745021759959e-05, 94: 0, 95: 0.00019393491636556732, 96: 0, 97: 0.060766273794544426, 98: 0.011003497754741593, 99: 0.020924192226442102, 100: 0.038611518348782715, 101: 0.10568067692520808, 102: 0.019642836529026746, 103: 0.01334226049615016, 104: 0.04489131564062013, 105: 0.04938875870109781, 106: 0.0009950708208757086, 107: 0.003991827028524594, 108: 0.02907869370981334, 109: 0.02376395350179505, 110: 0.05591559213640089, 111: 0.05791035127616101, 112: 0.013743982822907407, 113: 0.0007457259284056934, 114: 0.04792962933034735, 115: 0.048070463019612826, 116: 0.06875454534960232, 117: 0.0238770822030083, 118: 0.00873861498147229, 119: 0.017006245166056772, 120: 0.0015584055779375946, 121: 0.01792743601879322, 122: 0.0004917635379269742, 123: 0, 124: 0, 125: 0, 126: 0, 127: 0},
			},
			want:    nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := crackXorCipher(tt.args.cipherbytes, tt.args.freqs)
			if (err != nil) != tt.wantErr {
				t.Errorf("crackXorCipher() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("crackXorCipher() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_Crack(t *testing.T) {
	type args struct {
		ciphertext        string
		frequencyFilePath string
		frequencyDirPath  string
	}
	tests := []struct {
		name    string
		args    args
		want    string
		wantErr bool
	}{
		{
			name: "Test Crack run successfully 1",
			args: args{
				ciphertext:        "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736",
				frequencyFilePath: "frequency.json",
				frequencyDirPath:  "",
			},
			want:    "Cooking MC's like a pound of bacon",
			wantErr: false,
		},
		{
			name: "Test Crack run successfully 2",
			args: args{
				ciphertext:        "7b5a4215415d544115415d5015455447414c155c46155f4058455c5b523f",
				frequencyFilePath: "frequency.json",
				frequencyDirPath:  "",
			},
			want:    "Now that the party is jumping\n",
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Crack(tt.args.ciphertext, tt.args.frequencyFilePath, tt.args.frequencyDirPath)
			if (err != nil) != tt.wantErr {
				t.Errorf("Crack() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("Crack() got = %v, want %v", got, tt.want)
			}
		})
	}
}
